
//For quite some time now, all modern operating systems have implemented some form of data
//execution prevention.This means that you cannot just put code somwhere in memory and run it;
//the memory area has to be flagged to allow execution first.The reason is security -- it makes it
//much harder to exploit what would otherwise have been remote code execution vulnerablilities.
//
//It also means that you should think long and hard before you attempt something silly like this,
//because it rips a giant hole in your operating system's attempts to protect you.
//
//So, before you can run code from memory, you have to flag the area in question as executable.
//
//Under Windows, this can be done with VirtualProtect function.However, it cannot be done
//for arbitrary regions of memory; it has to be alligned at page boundaries, and the pages have to be
//allocated with  the same VirtualAlloc call.So, ultimatelly, you'll end up with

#include <iostream>
#include <windows.h>
using namespace std;

BYTE outCodeBuf[] =
{
0x07, 0xff, 0xff, 0x5c, 0x77, 0x30, 0x40, 0x00, 0x07, 0xff ,0xff ,0x5d ,0x02 ,0x00 ,0x00 ,0x00,
0x07 ,0xff ,0xff ,0x5c ,0x77 ,0x30 ,0x40 ,0x00 ,0x07 ,0xff ,0xff ,0x5d ,0x03 ,0x00 ,0x00 ,0x00,
0x07 ,0xff ,0xff ,0x5c ,0x77 ,0x30 ,0x40 ,0x00 ,0x07 ,0xff ,0xff ,0x5d, 0x04,0x00 ,0x00 ,0x00,
0x03 ,0xff ,0xff
};

DWORD outCodeMap[] =
{
0x10000000, 0x20000000, 0x30000000
};

extern BYTE _vm_poly_enc[] =
{
0x56, 0x50, 0x51, 0x8B, 0x74, 0x24, 0x10, 0x33, 0xC9, 0x8A, 0x06, 0x90, 0x90, 0x90, 0x90, 0x90,
0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x88, 0x06, 0x41, 0x46, 0x3B, 0x4C, 0x24,
0x14, 0x75, 0x96, 0x59, 0x58, 0x5E, 0xC2, 0x0C, 0x00
};
//+11


/*
push	esi
push	eax
push	ecx
mov	esi, dword ptr [esp + 10h]
xor	ecx, ecx
_loop:
mov	al, byte ptr [esi]


;...
db 60 DUP (90h)	;commands 2-bytes
db 30 DUP (90h)	;junks 3-bytes
;...

xor	eax, dword ptr [esp + 18h]
mov	byte ptr [esi], al
inc	ecx
inc	esi
cmp	ecx, dword ptr [esp + 14h]
jnz	_loop
pop	ecx
pop	eax
pop	esi
ret	0Ch
*/


int main()
{
	typedef void(__stdcall* polyFunc)(BYTE* buf, DWORD size, DWORD pos);
	polyFunc polyEnc = (polyFunc)(BYTE*)_vm_poly_enc;

	int tmpChr = 0;
	DWORD old_protect;
	LPVOID executable_area = VirtualAlloc(NULL, sizeof(_vm_poly_enc), MEM_RESERVE, PAGE_READWRITE);

	memcpy(executable_area, _vm_poly_enc, sizeof(_vm_poly_enc));
	VirtualProtect(executable_area, sizeof(_vm_poly_enc), PAGE_EXECUTE, &old_protect);

	polyEnc(outCodeBuf + outCodeMap[0] + tmpChr + 1, *(outCodeBuf + outCodeMap[0] + tmpChr), outCodeMap[0] + tmpChr);

	// Note: RAII this in C++. Restore old flags, free memory.
	VirtualProtect(executable_area, sizeof(_vm_poly_enc), old_protect, &old_protect);
	VirtualFree(executable_area, sizeof(_vm_poly_enc), MEM_RELEASE);

	return 0;
}
